data[i,2]=z
}
i=i+1
}
data=unique(data)
g=graph.edgelist(as.matrix(data[,c(1,2)]), directed = F) #cria o grafo
E(g)$time_initial=data[,4]#adiciona os tempos das arestas
E(g)$time_final=data[,5]#adiciona os tempos das arestas
#g=simplify(g,remove.multiple = F)
#generate a cool palette for the graph
YlOrBr <- c("#FFFFD4", "#FED98E", "#FE9929", "#D95F0E", "#993404")
YlOrBr.Lab <- colorRampPalette(YlOrBr, space = "Lab")
#colors for the nodes are chosen from the very beginning
vcolor <- rev(YlOrBr.Lab(vcount(g)))
ti=1
E(g)$weight <- ifelse(E(g)$time_initial == ti,1,0)
layout.old <- layout.fruchterman.reingold(g,params=list(weights=E(g)$weight))
#png(file="example%03d.png", width=1600,height=900)
nsteps <- max(E(g)$time_final)
total_time <- max(E(g)$time_final)
#x11()
#Time loop starts
z=0
w=0
for(ti in 0:total_time)
{
#define weight for edges present up to time ti.
E(g)$weight <- ifelse( ti == E(g)$time_initial & E(g)$time_final == ti, 1,0)
#Edges with non-zero weight are in gray. The rest are transparent
E(g)$color <- ifelse(E(g)$weight != 0,"red",rgb(0,0,0,0))
#Nodes with at least a non-zero weighted edge are in color. The rest are transparent
V(g)$color <- vcolor
#given the new weights, we update the layout a little bit
#   layout.new <- layout.fruchterman.reingold(g,params=list(niter=10,start=layout.old,weights=E(g)$weight,maxdelta=1))
g.modulos=multilevel.community(g)
z[i]=max(g.modulos$modularity)
w[i]=no.clusters(g)
#plot the new graph
#
#   plot(g
#        ,layout=layout.old
#        ,vertex.label=""
#        ,vertex.size=3#+2*log(graph.strength(g))
#        ,vertex.frame.color=V(g)$color
#        ,edge.width=1.5
#        ,asp=9/16
#        ,margin=-0.15
#        )
#use the new layout in the next round
#   layout.old <- layout.new
#ti=ti+1
}
plot(z)
plot (w)
w[i]=no.clusters(g)
no.clusters(g)
for(ti in 0:total_time)
{
#define weight for edges present up to time ti.
E(g)$weight <- ifelse( ti == E(g)$time_initial & E(g)$time_final == ti, 1,0)
#Edges with non-zero weight are in gray. The rest are transparent
E(g)$color <- ifelse(E(g)$weight != 0,"red",rgb(0,0,0,0))
#Nodes with at least a non-zero weighted edge are in color. The rest are transparent
V(g)$color <- vcolor
#given the new weights, we update the layout a little bit
#   layout.new <- layout.fruchterman.reingold(g,params=list(niter=10,start=layout.old,weights=E(g)$weight,maxdelta=1))
g.modulos=multilevel.community(g)
z[ti]=max(g.modulos$modularity)
w[ti]=no.clusters(g)
#plot the new graph
#
#   plot(g
#        ,layout=layout.old
#        ,vertex.label=""
#        ,vertex.size=3#+2*log(graph.strength(g))
#        ,vertex.frame.color=V(g)$color
#        ,edge.width=1.5
#        ,asp=9/16
#        ,margin=-0.15
#        )
#use the new layout in the next round
#   layout.old <- layout.new
#ti=ti+1
}
plot(z)
plot (w)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8')
plot(z)
plot (w)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8')
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8')
file="C:/Users/Vitor/Dropbox/Doutorado/codigo/socrats/build-Socrats_Doc_replicas-Desktop_Qt_5_3_MSVC2013_32bit-Debug/i_dyn_edge_0_tam_15_ags_15_raio_2_eps_3_mPts_4_tMem_10_nTurnos_200.txt"
data=as.data.frame(read.table(file, as.is=T, header= T, sep=";"))
# dado que as ids do r sempre começam com 1, é necessário importar os dados e somar 1 ao id
data[,1]=data[,1]+1#corrigindo valores de id
data[,2]=data[,2]+1#corrigindo valores de id
i=1
#removendo arestas repetidas
for (i in 1:length(data[,1]))
{
if(data[i,1] > data[i,2])
{
z=data[i,1]
data[i,1]=data[i,2]
data[i,2]=z
}
i=i+1
}
data=unique(data)
g=graph.edgelist(as.matrix(data[,c(1,2)]), directed = F) #cria o grafo
E(g)$time_initial=data[,4]#adiciona os tempos das arestas
E(g)$time_final=data[,5]#adiciona os tempos das arestas
#g=simplify(g,remove.multiple = F)
#generate a cool palette for the graph
YlOrBr <- c("#FFFFD4", "#FED98E", "#FE9929", "#D95F0E", "#993404")
YlOrBr.Lab <- colorRampPalette(YlOrBr, space = "Lab")
#colors for the nodes are chosen from the very beginning
vcolor <- rev(YlOrBr.Lab(vcount(g)))
ti=1
E(g)$weight <- ifelse(E(g)$time_initial == ti,1,0)
layout.old <- layout.fruchterman.reingold(g,params=list(weights=E(g)$weight))
#png(file="example%03d.png", width=1600,height=900)
nsteps <- max(E(g)$time_final)
total_time <- max(E(g)$time_final)
#x11()
#Time loop starts
z=0
w=0
E(g)$weight <- ifelse( ti == E(g)$time_initial & E(g)$time_final == ti, 1,0)
#Edges with non-zero weight are in gray. The rest are transparent
E(g)$color <- ifelse(E(g)$weight != 0,"red",rgb(0,0,0,0))
#Nodes with at least a non-zero weighted edge are in color. The rest are transparent
V(g)$color <- vcolor
#given the new weights, we update the layout a little bit
#   layout.new <- layout.fruchterman.reingold(g,params=list(niter=10,start=layout.old,weights=E(g)$weight,maxdelta=1))
g.modulos=multilevel.community(g)
z[ti]=max(g.modulos$modularity)
q=clusters(g)
w[ti]=q$no
clusters(g)
file="C:/Users/Vitor/Dropbox/Doutorado/codigo/socrats/build-Socrats_Doc_replicas-Desktop_Qt_5_3_MSVC2013_32bit-Debug/i_dyn_edge_0_tam_15_ags_15_raio_2_eps_3_mPts_4_tMem_10_nTurnos_200.txt"
data=as.data.frame(read.table(file, as.is=T, header= T, sep=";"))
# dado que as ids do r sempre começam com 1, é necessário importar os dados e somar 1 ao id
data[,1]=data[,1]+1#corrigindo valores de id
data[,2]=data[,2]+1#corrigindo valores de id
i=1
#removendo arestas repetidas
for (i in 1:length(data[,1]))
{
if(data[i,1] > data[i,2])
{
z=data[i,1]
data[i,1]=data[i,2]
data[i,2]=z
}
i=i+1
}
data=unique(data)
g=graph.edgelist(as.matrix(data[,c(1,2)]), directed = F) #cria o grafo
E(g)$time_initial=data[,4]#adiciona os tempos das arestas
E(g)$time_final=data[,5]#adiciona os tempos das arestas
#g=simplify(g,remove.multiple = F)
#generate a cool palette for the graph
YlOrBr <- c("#FFFFD4", "#FED98E", "#FE9929", "#D95F0E", "#993404")
YlOrBr.Lab <- colorRampPalette(YlOrBr, space = "Lab")
#colors for the nodes are chosen from the very beginning
vcolor <- rev(YlOrBr.Lab(vcount(g)))
ti=0
E(g)$weight <- ifelse(E(g)$time_initial == ti,1,0)
layout.old <- layout.fruchterman.reingold(g,params=list(weights=E(g)$weight))
#png(file="example%03d.png", width=1600,height=900)
nsteps <- max(E(g)$time_final)
total_time <- max(E(g)$time_final)
#x11()
#Time loop starts
z=0
w=0
#define weight for edges present up to time ti.
E(g)$weight <- ifelse( ti == E(g)$time_initial & E(g)$time_final == ti, 1,0)
#Edges with non-zero weight are in gray. The rest are transparent
E(g)$color <- ifelse(E(g)$weight != 0,"red",rgb(0,0,0,0))
#Nodes with at least a non-zero weighted edge are in color. The rest are transparent
V(g)$color <- vcolor
#given the new weights, we update the layout a little bit
#   layout.new <- layout.fruchterman.reingold(g,params=list(niter=10,start=layout.old,weights=E(g)$weight,maxdelta=1))
g.modulos=multilevel.community(g)
z[ti]=max(g.modulos$modularity)
q=clusters(g)
w[ti]=q$no
plot(g
,layout=layout.old
,vertex.label=""
,vertex.size=3#+2*log(graph.strength(g))
,vertex.frame.color=V(g)$color
,edge.width=1.5
,asp=9/16
,margin=-0.15
)
use the new layout in the next round
layout.old <- layout.new
#define weight for edges present up to time ti.
E(g)$weight <- ifelse( ti == E(g)$time_initial & E(g)$time_final == ti, 1,0)
#Edges with non-zero weight are in gray. The rest are transparent
E(g)$color <- ifelse(E(g)$weight != 0,"black",rgb(0,0,0,0))
#Nodes with at least a non-zero weighted edge are in color. The rest are transparent
V(g)$color <- vcolor
#given the new weights, we update the layout a little bit
#   layout.new <- layout.fruchterman.reingold(g,params=list(niter=10,start=layout.old,weights=E(g)$weight,maxdelta=1))
g.modulos=multilevel.community(g)
z[ti]=max(g.modulos$modularity)
q=clusters(g)
w[ti]=q$no
#plot the new graph
plot(g
,layout=layout.old
,vertex.label=""
,vertex.size=3#+2*log(graph.strength(g))
,vertex.frame.color=V(g)$color
,edge.width=1.5
,asp=9/16
,margin=-0.15
)
use the new layout in the next round
layout.old <- layout.new
ti=ti+1
#define weight for edges present up to time ti.
E(g)$weight <- ifelse( ti == E(g)$time_initial & E(g)$time_final == ti, 1,0)
#Edges with non-zero weight are in gray. The rest are transparent
E(g)$color <- ifelse(E(g)$weight != 0,"black",rgb(0,0,0,0))
#Nodes with at least a non-zero weighted edge are in color. The rest are transparent
V(g)$color <- vcolor
#given the new weights, we update the layout a little bit
#   layout.new <- layout.fruchterman.reingold(g,params=list(niter=10,start=layout.old,weights=E(g)$weight,maxdelta=1))
g.modulos=multilevel.community(g)
z[ti]=max(g.modulos$modularity)
q=clusters(g)
w[ti]=q$no
#plot the new graph
plot(g
,layout=layout.old
,vertex.label=""
,vertex.size=3#+2*log(graph.strength(g))
,vertex.frame.color=V(g)$color
,edge.width=1.5
,asp=9/16
,margin=-0.15
)
use the new layout in the next round
layout.old <- layout.new
ti=ti+1
#define weight for edges present up to time ti.
E(g)$weight <- ifelse( ti == E(g)$time_initial & E(g)$time_final == ti, 1,0)
#Edges with non-zero weight are in gray. The rest are transparent
E(g)$color <- ifelse(E(g)$weight != 0,"black",rgb(0,0,0,0))
#Nodes with at least a non-zero weighted edge are in color. The rest are transparent
V(g)$color <- vcolor
#given the new weights, we update the layout a little bit
#  layout.new <- layout.fruchterman.reingold(g,params=list(niter=10,start=layout.old,weights=E(g)$weight,maxdelta=1))
g.modulos=multilevel.community(g)
z[ti]=max(g.modulos$modularity)
q=clusters(g)
w[ti]=q$no
#plot the new graph
plot(g
,layout=layout.old
,vertex.label=""
,vertex.size=3#+2*log(graph.strength(g))
,vertex.frame.color=V(g)$color
,edge.width=1.5
,asp=9/16
,margin=-0.15
)
use the new layout in the next round
layout.old <- layout.new
ti=ti+1
#define weight for edges present up to time ti.
E(g)$weight <- ifelse( ti == E(g)$time_initial & E(g)$time_final == ti, 1,0)
#Edges with non-zero weight are in gray. The rest are transparent
E(g)$color <- ifelse(E(g)$weight != 0,"black",rgb(0,0,0,0))
#Nodes with at least a non-zero weighted edge are in color. The rest are transparent
V(g)$color <- vcolor
#given the new weights, we update the layout a little bit
#  layout.new <- layout.fruchterman.reingold(g,params=list(niter=10,start=layout.old,weights=E(g)$weight,maxdelta=1))
g.modulos=multilevel.community(g)
z[ti]=max(g.modulos$modularity)
q=clusters(g)
w[ti]=q$no
#plot the new graph
plot(g
,layout=layout.old
,vertex.label=""
,vertex.size=3#+2*log(graph.strength(g))
,vertex.frame.color=V(g)$color
,edge.width=1.5
,asp=9/16
,margin=-0.15
)
use the new layout in the next round
layout.old <- layout.new
ti=ti+1
#define weight for edges present up to time ti.
E(g)$weight <- ifelse( ti == E(g)$time_initial & E(g)$time_final == ti, 1,0)
#Edges with non-zero weight are in gray. The rest are transparent
E(g)$color <- ifelse(E(g)$weight != 0,"black",rgb(0,0,0,0))
#Nodes with at least a non-zero weighted edge are in color. The rest are transparent
V(g)$color <- vcolor
#given the new weights, we update the layout a little bit
#  layout.new <- layout.fruchterman.reingold(g,params=list(niter=10,start=layout.old,weights=E(g)$weight,maxdelta=1))
g.modulos=multilevel.community(g)
z[ti]=max(g.modulos$modularity)
q=clusters(g)
w[ti]=q$no
#plot the new graph
plot(g
,layout=layout.old
,vertex.label=""
,vertex.size=3#+2*log(graph.strength(g))
,vertex.frame.color=V(g)$color
,edge.width=1.5
,asp=9/16
,margin=-0.15
)
use the new layout in the next round
layout.old <- layout.new
ti=ti+1
#define weight for edges present up to time ti.
E(g)$weight <- ifelse( ti == E(g)$time_initial & E(g)$time_final == ti, 1,0)
#Edges with non-zero weight are in gray. The rest are transparent
E(g)$color <- ifelse(E(g)$weight != 0,"black",rgb(0,0,0,0))
#Nodes with at least a non-zero weighted edge are in color. The rest are transparent
V(g)$color <- vcolor
#given the new weights, we update the layout a little bit
#  layout.new <- layout.fruchterman.reingold(g,params=list(niter=10,start=layout.old,weights=E(g)$weight,maxdelta=1))
g.modulos=multilevel.community(g)
z[ti]=max(g.modulos$modularity)
q=clusters(g)
w[ti]=q$no
#plot the new graph
plot(g
,layout=layout.old
,vertex.label=""
,vertex.size=3#+2*log(graph.strength(g))
,vertex.frame.color=V(g)$color
,edge.width=1.5
,asp=9/16
,margin=-0.15
)
use the new layout in the next round
layout.old <- layout.new
ti=ti+1
#define weight for edges present up to time ti.
E(g)$weight <- ifelse( ti == E(g)$time_initial & E(g)$time_final == ti, 1,0)
#Edges with non-zero weight are in gray. The rest are transparent
E(g)$color <- ifelse(E(g)$weight != 0,"black",rgb(0,0,0,0))
#Nodes with at least a non-zero weighted edge are in color. The rest are transparent
V(g)$color <- vcolor
#given the new weights, we update the layout a little bit
#  layout.new <- layout.fruchterman.reingold(g,params=list(niter=10,start=layout.old,weights=E(g)$weight,maxdelta=1))
g.modulos=multilevel.community(g)
z[ti]=max(g.modulos$modularity)
q=clusters(g)
w[ti]=q$no
#plot the new graph
plot(g
,layout=layout.old
,vertex.label=""
,vertex.size=3#+2*log(graph.strength(g))
,vertex.frame.color=V(g)$color
,edge.width=1.5
,asp=9/16
,margin=-0.15
)
use the new layout in the next round
layout.old <- layout.new
ti=ti+1
#define weight for edges present up to time ti.
E(g)$weight <- ifelse( ti == E(g)$time_initial & E(g)$time_final == ti, 1,0)
#Edges with non-zero weight are in gray. The rest are transparent
E(g)$color <- ifelse(E(g)$weight != 0,"black",rgb(0,0,0,0))
#Nodes with at least a non-zero weighted edge are in color. The rest are transparent
V(g)$color <- vcolor
#given the new weights, we update the layout a little bit
#  layout.new <- layout.fruchterman.reingold(g,params=list(niter=10,start=layout.old,weights=E(g)$weight,maxdelta=1))
g.modulos=multilevel.community(g)
z[ti]=max(g.modulos$modularity)
q=clusters(g)
w[ti]=q$no
#plot the new graph
plot(g
,layout=layout.old
,vertex.label=""
,vertex.size=3#+2*log(graph.strength(g))
,vertex.frame.color=V(g)$color
,edge.width=1.5
,asp=9/16
,margin=-0.15
)
use the new layout in the next round
layout.old <- layout.new
ti=ti+1
#define weight for edges present up to time ti.
E(g)$weight <- ifelse( ti == E(g)$time_initial & E(g)$time_final == ti, 1,0)
#Edges with non-zero weight are in gray. The rest are transparent
E(g)$color <- ifelse(E(g)$weight != 0,"black",rgb(0,0,0,0))
#Nodes with at least a non-zero weighted edge are in color. The rest are transparent
V(g)$color <- vcolor
#given the new weights, we update the layout a little bit
#  layout.new <- layout.fruchterman.reingold(g,params=list(niter=10,start=layout.old,weights=E(g)$weight,maxdelta=1))
g.modulos=multilevel.community(g)
z[ti]=max(g.modulos$modularity)
q=clusters(g)
w[ti]=q$no
#plot the new graph
plot(g
,layout=layout.old
,vertex.label=""
,vertex.size=3#+2*log(graph.strength(g))
,vertex.frame.color=V(g)$color
,edge.width=1.5
,asp=9/16
,margin=-0.15
)
use the new layout in the next round
layout.old <- layout.new
ti=ti+1
#define weight for edges present up to time ti.
E(g)$weight <- ifelse( ti == E(g)$time_initial & E(g)$time_final == ti, 1,0)
#Edges with non-zero weight are in gray. The rest are transparent
E(g)$color <- ifelse(E(g)$weight != 0,"black",rgb(0,0,0,0))
#Nodes with at least a non-zero weighted edge are in color. The rest are transparent
V(g)$color <- vcolor
#given the new weights, we update the layout a little bit
#  layout.new <- layout.fruchterman.reingold(g,params=list(niter=10,start=layout.old,weights=E(g)$weight,maxdelta=1))
g.modulos=multilevel.community(g)
z[ti]=max(g.modulos$modularity)
q=clusters(g)
w[ti]=q$no
#plot the new graph
plot(g
,layout=layout.old
,vertex.label=""
,vertex.size=3#+2*log(graph.strength(g))
,vertex.frame.color=V(g)$color
,edge.width=1.5
,asp=9/16
,margin=-0.15
)
use the new layout in the next round
layout.old <- layout.new
ti=ti+1
plot(z)
replica.med=function(type,d,metric)#type = memory type, d= agent density
{
if (metric != "meanSize" | metric != "meanNumber" | StandardDev)
{return ("error")}
sd.medios.por.mem=as.data.frame(data.frame(matrix(NA, nrow = n_iter, ncol = length(mem_lengths))))
colnames(sd.medios.por.mem) = mem_lengths
for (i in 1:length(mem_lengths))
{
i_sd=0
sd=0
#create file list with selected memory lengths
reg.exp=paste(
#'i_var.*' #only group memory
paste(type,"sd*",sep="")
#,mem_lengths[i]
,paste("tam_", d, sep="") #only one density
,'.*'
,paste("tMem_", mem_lengths[i],"_", sep="")#only one memory length
#,'.*'
,sep="")
#reg.exp2=grep(pattern=reg.exp,files,value=TRUE)
i_sd=list.files(pattern = reg.exp)
#i_sd=list.files(pattern = temp)
#read files
tablesisd <- lapply(i_sd, read.table, header = FALSE)
#calculates average group size for given memory length
sd=as.data.frame(tablesisd)#dados brutos
#w=function(x){x[is.nan(x)] <- 0;return(x)}
#   w=function(x){
#     x[is.nan(x)] <- 0
#     x[is.na<-(x)] <- 0
#     return(x)}
#sd=apply(tam.medio.por.replicas,FUN=w, MARGIN=c(2))
#sd.medios[,i]= as.data.frame(rowSds(sd), na.rm=FALSE)
sd.medios.por.mem[,i]= as.data.frame(rowSds(as.matrix(sd)), na.rm=TRUE)
}
return (sd.medios.por.mem)
}
setwd("C:/Users/Vitor/Dropbox/Doutorado/codigo/socrats/build-Socrats_Doc_replicas-Desktop_Qt_5_4_0_MinGW_32bit-Debug/debug/")
#setwd("C:/Users/Vrios/Dropbox/Doutorado/codigo/socrats/Socrats_Doc_replicas")
library("matrixStats") #rowSds() function <- now needs a matrix instead of a data.frame
# list files with .txt extension
files  <- list.files(pattern = '.txt')
#read memory lengths from filenames
temp_length <- read.table(textConnection(files), sep = "_")
unique(temp_length[2])
mem_lengths = unique(temp_length[16])
mem_lengths=sort(mem_lengths[,])
#read number of iterations from filenames
n_iter= as.numeric(temp_length[1,14])
#
n_iter # numero de iterações
#read densities from filenames
worldSize=unique(temp_length[,6])
sizes=(unique(temp_length[,4]))
densities = worldSize/sizes^2 # individuals per square unit
#read number of replicates from filenames
n_rep = as.character(unique(temp_length[,18]))
n_rep=strtrim(n_rep, nchar(n_rep)-4)
#expressão regular g_tam.*tMem_2000.* -> retorna tudo que tiver g_tam e tMem_2000 em qualquer lugar da string
type="g"
